#include <algorithm>
#include <MinHook.h>
#include "unrandomizer.h"
#include "../log.h"
#include "../hooks/score_invalidator_hook.h"

namespace iidxtra::unrandomizer
{
	// options
    auto enabled_p1 = false;
    auto enabled_p2 = false;

    auto allow_score_save_p1 = false;
    auto allow_score_save_p2 = false;

	auto show_random_info_p1 = false;
	auto show_random_info_p2 = false;

	// state
	auto column_lut_p1 = random_lut_t { 0, 1, 2, 3, 4, 5, 6 };
    auto column_lut_p2 = random_lut_t { 0, 1, 2, 3, 4, 5, 6 };

    // original functions
    void* original_game_apply_random_fn = nullptr;

	auto is_valid(const std::uint8_t player) -> bool
	{
		auto seen = std::array<bool, 7> {};

		for (auto const i: player == 0 ? column_lut_p1: column_lut_p2)
			seen[i] = true;

		return std::ranges::all_of(seen, [] (auto v) { return v; });
	}

    auto reset() -> void
    {
	    auto constexpr lut_default = random_lut_t { 0, 1, 2, 3, 4, 5, 6 };
        enabled_p1 = false;
        enabled_p2 = false;
        allow_score_save_p1 = false;
        allow_score_save_p2 = false;
        show_random_info_p1 = false;
        show_random_info_p2 = false;
		std::ranges::copy(lut_default, column_lut_p1.begin());
		std::ranges::copy(lut_default, column_lut_p2.begin());
    }

	auto apply_force_random(std::uint8_t player) -> void
	{
		// pre-flight checks
		auto const enabled = (player == 0 ? enabled_p1: enabled_p2);
		auto const valid = (enabled && is_valid(player));

		if (!enabled || !valid)
			return;

		// convert textage compatible setting into value expected by the game
		auto const& lut = (player == 0 ? column_lut_p1 : column_lut_p2);

		for (auto i = 0; i < 7; i++)
		{
			auto const value = lut[i];
			bm2dx::random_data->columns[player][value] = i;
		}

        // if player is present, invalidate score
        if (player == 0 && bm2dx::state->p1_active && !allow_score_save_p1)
            score_invalidator_hook::invalidate(0);
        else if (player == 1 && bm2dx::state->p2_active && !allow_score_save_p2)
            score_invalidator_hook::invalidate(1);
	}

	auto game_random_to_string(const std::uint8_t player, random_lut_t& values) -> std::string
	{
		auto result = std::string {};

		for (auto i = 0; i < 7; i++)
		{
			auto const value = bm2dx::random_data->columns[player][i];
			values[value] = i;
		}

		for (auto const column: values)
			result.append(std::to_string(column + 1));

		return result;
	}

	auto print_random_info(const std::uint8_t player) -> void
	{
		// get current random as string
		auto translated_random = random_lut_t {};
		auto current = game_random_to_string(player, translated_random);

		// don't display 1234567 (non-ran, s-ran)
		if (current != "1234567")
		{
			auto type = std::string { "?" };

			if (bm2dx::state->play_style == 1)
			{
				type = (player == 0 ? "LEFT": "RIGHT");
				log::print("[Un-randomizer] RANDOM: {} ({})", current, type);
			}
			else
			{
				if (player == 0 && bm2dx::state->p1_active && (show_random_info_p1 || enabled_p1))
					log::print("[Un-randomizer] P1 RANDOM: {}{}", current, (enabled_p1 ? " (CUSTOM)": ""));
				else if (player == 1 && bm2dx::state->p2_active && (show_random_info_p2 || enabled_p2))
					log::print("[Un-randomizer] P2 RANDOM: {}{}", current, (enabled_p2 ? " (CUSTOM)": ""));
			}
		}

		// update lut value to use the random just generated by the game
		// (makes playing or keeping track of good randoms easier)
		if (player == 0 && !enabled_p1)
			std::ranges::copy(translated_random, column_lut_p1.begin());

		if (player == 1 && !enabled_p2)
			std::ranges::copy(translated_random, column_lut_p2.begin());
	}

	void install_hook()
	{
		MH_CreateHook(bm2dx::addr->APPLY_RANDOM_FN, (void*) +[] (void* a1) -> char
		{
			// apply game random immediately
			auto const result = reinterpret_cast<char (*) (void*)>
				(original_game_apply_random_fn) (a1);

			apply_force_random(0);
			apply_force_random(1);

			print_random_info(0);
			print_random_info(1);

			return result;
		}, &original_game_apply_random_fn);
	}
}